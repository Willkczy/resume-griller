<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Resume Griller - Voice & WebSocket Test</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; max-width: 900px; margin: 0 auto; padding: 20px; background-color: #f5f5f5; }
        .container { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .status-bar { padding: 10px; border-radius: 4px; margin-bottom: 20px; font-weight: bold; }
        .status-connected { background-color: #d4edda; color: #155724; }
        .status-disconnected { background-color: #f8d7da; color: #721c24; }
        
        .control-panel { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px; }
        .input-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; font-weight: bold; }
        input[type="text"] { width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; box-sizing: border-box; }
        
        button { padding: 10px 20px; cursor: pointer; border: none; border-radius: 4px; font-weight: bold; transition: background 0.2s; }
        .btn-primary { background-color: #007bff; color: white; }
        .btn-primary:hover { background-color: #0056b3; }
        .btn-danger { background-color: #dc3545; color: white; }
        .btn-success { background-color: #28a745; color: white; }
        .btn-record { background-color: #ffc107; color: #333; display: flex; align-items: center; justify-content: center; gap: 10px; }
        .btn-record.recording { background-color: #dc3545; color: white; animation: pulse 1.5s infinite; }
        
        #log { height: 400px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; background: #fafafa; border-radius: 4px; font-family: monospace; white-space: pre-wrap; }
        .log-entry { margin-bottom: 5px; padding: 5px; border-bottom: 1px solid #eee; }
        .log-sent { color: #0056b3; }
        .log-received { color: #28a745; }
        .log-error { color: #dc3545; }
        .log-info { color: #666; font-style: italic; }
        .log-transcript { color: #fd7e14; font-weight: bold; }

        .audio-player { margin-top: 5px; width: 100%; }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
    </style>
</head>
<body>

<div class="container">
    <h1>üé§ Resume Griller Debugger</h1>
    
    <div id="connectionStatus" class="status-bar status-disconnected">Disconnected</div>

    <div class="control-panel">
        <div>
            <h3>1. Connection</h3>
            <div class="input-group">
                <label for="sessionId">Session ID:</label>
                <input type="text" id="sessionId" placeholder="Enter Session ID (e.g. uuid)" value="">
            </div>
            <button onclick="connect()" class="btn-primary">Connect</button>
            <button onclick="disconnect()" class="btn-danger">Disconnect</button>
        </div>

        <div>
            <h3>2. Actions</h3>
            <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                <button onclick="sendStart()" class="btn-success">Start Interview</button>
                <button onclick="sendSkip()" class="btn-primary">Skip Question</button>
                <button onclick="sendEnd()" class="btn-danger">End Interview</button>
            </div>
            
            <div class="input-group">
                <label>3. Answer (Text or Voice)</label>
                <div style="display: flex; gap: 5px;">
                    <input type="text" id="answerInput" placeholder="Type answer here...">
                    <button onclick="sendTextAnswer()" class="btn-primary">Send Text</button>
                </div>
                <div style="margin-top: 10px;">
                    <button id="recordBtn" onmousedown="startRecording()" onmouseup="stopRecording()" class="btn-record">
                        <span>üéôÔ∏è Hold to Speak</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <h3>Event Log</h3>
    <div id="log"></div>
</div>

<script>
    let ws = null;
    let mediaRecorder = null;
    let audioChunks = [];

    // --- WebSocket Functions ---

    function connect() {
        const sessionId = document.getElementById('sessionId').value;
        if (!sessionId) {
            alert("Please enter a Session ID first (Create one via POST /api/v1/sessions)");
            return;
        }

        const wsUrl = `ws://localhost:8000/ws/interview/${sessionId}`;
        log(`Connecting to ${wsUrl}...`, 'info');

        ws = new WebSocket(wsUrl);

        ws.onopen = () => {
            const statusDiv = document.getElementById('connectionStatus');
            statusDiv.textContent = 'Connected';
            statusDiv.className = 'status-bar status-connected';
            log('WebSocket Connected', 'info');
        };

        ws.onmessage = async (event) => {
            const data = JSON.parse(event.data);
            
            // Handle Audio Playback
            if (data.audio_base64) {
                log(`üîä Received Audio (${data.type})`, 'received');
                playAudio(data.audio_base64);
                // Remove big base64 string from log for readability
                data.audio_base64 = "[BASE64_AUDIO_DATA_HIDDEN]";
            }

            // Handle Transcript (What AI heard)
            if (data.type === 'transcript') {
                log(`üó£Ô∏è AI Heard: "${data.content}" (Confidence: ${data.data.confidence})`, 'transcript');
                return;
            }

            // Log the rest of the message
            log(`RX: ${JSON.stringify(data, null, 2)}`, 'received');
        };

        ws.onclose = () => {
            const statusDiv = document.getElementById('connectionStatus');
            statusDiv.textContent = 'Disconnected';
            statusDiv.className = 'status-bar status-disconnected';
            log('WebSocket Disconnected', 'error');
            ws = null;
        };

        ws.onerror = (error) => {
            log('WebSocket Error', 'error');
        };
    }

    function disconnect() {
        if (ws) ws.close();
    }

    function sendStart() {
        sendJson({ type: "start", data: { num_questions: 3 } });
    }

    function sendTextAnswer() {
        const input = document.getElementById('answerInput');
        const text = input.value;
        if (text) {
            sendJson({ type: "answer", content: text });
            input.value = '';
        }
    }

    function sendSkip() {
        sendJson({ type: "skip" });
    }

    function sendEnd() {
        sendJson({ type: "end" });
    }

    function sendJson(data) {
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify(data));
            log(`TX: ${JSON.stringify(data)}`, 'sent');
        } else {
            log("Error: WebSocket not connected", 'error');
        }
    }

    // --- Audio / Voice Functions ---

    // 1. Play Audio from Base64
    function playAudio(base64String) {
        try {
            const audio = new Audio("data:audio/mp3;base64," + base64String);
            audio.play().catch(e => log(`Autoplay blocked: ${e}`, 'error'));
        } catch (e) {
            log(`Error playing audio: ${e}`, 'error');
        }
    }

    // 2. Recording Logic
    async function startRecording() {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            alert("Browser does not support audio recording.");
            return;
        }

        const btn = document.getElementById('recordBtn');
        btn.classList.add('recording');
        btn.innerHTML = "<span>üî¥ Recording... Release to Send</span>";

        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
            audioChunks = [];

            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    audioChunks.push(event.data);
                }
            };

            mediaRecorder.onstop = () => {
                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                convertBlobToBase64(audioBlob).then(base64 => {
                    // Send as ANSWER_AUDIO
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        // Strip the "data:audio/webm;base64," prefix
                        const rawBase64 = base64.split(',')[1];
                        
                        ws.send(JSON.stringify({
                            type: "answer_audio",
                            content: rawBase64
                        }));
                        log("TX: [Audio Data Sent]", 'sent');
                    }
                });
                
                // Stop all tracks to release microphone
                stream.getTracks().forEach(track => track.stop());
            };

            mediaRecorder.start();
            log("Recording started...", 'info');

        } catch (err) {
            console.error(err);
            log(`Microphone Error: ${err.message}`, 'error');
            btn.classList.remove('recording');
            btn.innerHTML = "<span>üéôÔ∏è Hold to Speak</span>";
        }
    }

    function stopRecording() {
        const btn = document.getElementById('recordBtn');
        btn.classList.remove('recording');
        btn.innerHTML = "<span>üéôÔ∏è Hold to Speak</span>";

        if (mediaRecorder && mediaRecorder.state !== 'inactive') {
            mediaRecorder.stop();
            log("Recording stopped. Processing...", 'info');
        }
    }

    function convertBlobToBase64(blob) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(blob);
        });
    }

    // --- Utility ---

    function log(message, type) {
        const logDiv = document.getElementById('log');
        const entry = document.createElement('div');
        entry.className = `log-entry log-${type}`;
        entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
        logDiv.appendChild(entry);
        logDiv.scrollTop = logDiv.scrollHeight;
    }
</script>

</body>
</html>